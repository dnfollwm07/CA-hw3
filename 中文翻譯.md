

透過這次作業，您將在實際的數據軌跡（應用程序）上測試您在 HW4 中編寫的 cache sa.py 代碼。現在有一個名為 memory.py 的新文件，其中包含 Memory (DRAM) 的類。在更改代碼之前，請先理解現有代碼（我們對之前的版本進行了一些更改）。

1. 由於我們對 cache sa.py 文件進行了一些小的更改，在運行實驗之前，請先將您在 HW4 中的函數定義複製到當前文件中。
2. 要模擬快取，請到包含 sim sa.py 文件的目錄並使用以下命令：
   ```
   python3 sim sa.py <TRACE 文件路徑> <CACHE 大小> <WAYS> <BLOCK 大小> <TRACE 元素>
   ```
   在本次作業中，我們將使用來自真實應用的數據軌跡。這些真實的數據軌跡（應用程序）可以從這裡下載：https://github.com/adwaitjog/ramulator
   更多關於真實數據軌跡的信息可以在 README.md 中找到。在本次作業中，我們主要使用以下 4 種數據軌跡，但您也可以使用更多的真實數據軌跡。
   1. 462.libquantum.gz 
   2. 464.h264ref.gz 
   3. 403.gcc.gz 
   4. 445.gobmk.gz

提交內容

1. 兩個 python 文件，分別為 cache sa.py（用於 Cache）和 memory.py（用於任務 1）。請不要更改 Python 文件的名稱。
2. 一份報告，其中包含：
   (a) 運行真實數據軌跡時的代碼輸出。
   (b) 記錄您的觀察結果（建議使用圖表），並提交 PDF。建議報告長度為三頁。
   展示您的工作不是選擇性的，並且您的最終得分將高度依賴於報告的質量。

1 任務

這次作業包含以下三個任務：

1.1 完成簡單的快取-記憶體模擬器：20 分
在 memory.py 中完成 determine miss penalty 函數。該函數最多包含五行 Python 代碼，您可以使用 Memory 類定義中已經定義的其他方法（在使用之前先理解它們！）。

1.2 使用真實數據軌跡進行驗證：40 分
將您完成的記憶體-快取模擬器的輸出軌跡與資源文件夾中提供的軌跡進行驗證（資源/輸出文件）。如果不匹配，請對 cache sa.py 或 memory.py 進行調試。

1.3 快取設計空間探索：40 分
找出以下三個參數如何影響快取失誤率：
1. 快取大小
2. 區塊大小
3. 連結度

我們的目標是設計出一個能在多種應用程序（數據軌跡）上平均表現良好的「通用」快取設計。在完成任務 1 和 2 後，找到一個平均表現最佳的連結度和快取區塊大小組合，以便適用於儘可能多的真實數據軌跡。評估設計優劣的指標為 CPI stall（越低越好）。CPI stall 的計算公式已在 sim sa.py 中給出。特定快取設計 X（即快取大小、連結度和區塊大小的組合）的 CPI stall 是使用不同數據軌跡在同一快取設計 X 下獲得的 CPI stall 數值的幾何平均值。

為了限制設計空間，您可以假設以下限制。請至少在以下四種數據軌跡上進行測試：
1. 462.libquantum.gz
2. 464.h264ref.gz
3. 403.gcc.gz
4. 445.gobmk.gz

在所有實驗中保持快取大小不變：16384（16KB），這是現代處理器中 L1 快取的合理大小。連結度可以設置為 1 路（直接映射）、4 路、8 路、16 路和 32 路。區塊大小可以設置為 128B、256B、512B、2048B。此外，您還可以考慮如 4096B、16384B 的區塊大小。某些區塊大小（特別是大於 512B 的）在實際應用中並不常見，但提供了有趣的見解。請使用數據/圖表分析您的結果。

1.4 使用真實數據軌跡的示例命令行

```
python3 sim\ sa.py 403.gcc.gz 16384 16 128 1000
```
• 其中 403.gcc.gz 是存儲於 ../traces 中的軌跡文件
• 16384 是快取大小（字節）
• 2 是路數
• 128 是每個區塊的字節數（即 BlockBits = 7，其中 2 為位元組偏移，5 為區塊偏移，因為共有 32 個字）
• 新增！1000 表示從軌跡文件中模擬的行數。每個軌跡文件包含數十萬行。